<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Flashcards</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500&display=swap" rel="stylesheet">
  <style>
    * { box-sizing: border-box; margin: 0; font-family: 'Inter', sans-serif; }
    body { margin: 0 auto; padding: 80px 40px; min-height: 100vh; display: flex; flex-direction: column; justify-content: flex-start; background: #0f172a; }
    input, textarea { width: 100%; padding: 16px 20px; font-size: 16px; background: #1e293b; color: #f8fafc; border: 1px solid #334155; border-radius: 8px; margin-top: 12px; outline: none; transition: border-color 0.2s; }
    input::placeholder, textarea::placeholder { color: #64748b; }
    input:focus, textarea:focus { border-color: #60a5fa; }
    .card { position: relative; padding: 16px 40px; background: #1e293b; border: 1px solid #334155; border-radius: 12px; text-align: center; box-shadow: 0 4px 24px rgba(0,0,0,0.3); transition: opacity 0.15s; display: flex; flex-direction: column; align-items: center; max-width: 1000px; margin: 0 auto; }
    .card.fade { opacity: 0; }
    .card.shake { animation: shake 0.4s; }
    @keyframes shake { 20%,60% { transform: translateX(-8px); } 40%,80% { transform: translateX(8px); } }
    .card input { text-align: center; background: #0f172a; transition: border-color 0.3s; }
    .card input.correct { border-color: #22c55e; }
    .card input.wrong { border-color: #ef4444; }
    .stats { width: 100%; display: flex; justify-content: space-between; font-size: 12px; color: #64748b; margin-bottom: 11px; text-transform: uppercase; letter-spacing: 0.5px; opacity: 0.5; transition: opacity 0.2s; }
    .card:hover .stats { opacity: 1; }
    .progress { width: 100%; height: 2px; background: #334155; border-radius: 2px; margin-bottom: 22px; }
    .progress-bar { height: 100%; background: #60a5fa; border-radius: 2px; transition: width 0.3s; }
    .ex { display: inline-block; font-size: 24px; color: #f8fafc; line-height: 1.8; background: #0f172a; padding: 11px 22px; border-radius: 8px; border: 1px solid #334155; transition: opacity 0.2s; }
    .def { font-size: 15px; color: #94a3b8; line-height: 1.6; margin-top: 11px; font-style: italic; padding: 5px 0; }
    .modal { display: none; position: fixed; inset: 0; background: #0f172a; padding: 40px; overflow: auto; z-index: 100; }
    .modal-inner { max-width: 480px; margin: 0 auto; }
    .modal-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 32px; padding-bottom: 20px; border-bottom: 1px solid #334155; }
    .modal-title { font-size: 18px; font-weight: 500; color: #f8fafc; }
    .modal-close { width: 24px; height: 24px; cursor: pointer; opacity: 0.5; transition: opacity 0.2s; }
    .modal-close:hover { opacity: 1; }
    .modal input, .modal textarea { text-align: left; }
    .modal textarea { height: 100px; resize: none; }
    .btns { display: flex; flex-wrap: wrap; gap: 10px; margin-top: 20px; }
    .btn { display: flex; align-items: center; gap: 8px; padding: 12px 20px; background: #1e293b; border: 1px solid #334155; border-radius: 8px; cursor: pointer; font-size: 14px; color: #94a3b8; transition: all 0.2s; }
    .btn:hover { border-color: #60a5fa; color: #f8fafc; }
    .btn:hover svg { stroke: #60a5fa; }
    .btn svg { width: 16px; height: 16px; stroke: #64748b; transition: stroke 0.2s; }
    .btn-primary { background: #3b82f6; border-color: #3b82f6; color: #fff; }
    .btn-primary svg { stroke: #fff; }
    .btn-primary:hover { background: #2563eb; border-color: #2563eb; color: #fff; }
    .btn-primary:hover svg { stroke: #fff; }
    .btn-danger { border-color: #dc2626; color: #dc2626; }
    .btn-danger svg { stroke: #dc2626; }
    .btn-danger:hover { background: #dc2626; border-color: #dc2626; color: #fff; }
    .btn-danger:hover svg { stroke: #fff; }
    .btn-danger:disabled { opacity: 0.4; cursor: not-allowed; background: transparent; color: #dc2626; }
    .btn-danger:disabled svg { stroke: #dc2626; }
    .section { margin-top: 48px; }
    .section:first-of-type { margin-top: 0; }
    .section-label { font-size: 11px; color: #64748b; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 4px; }
    .danger-zone { margin-top: 48px; padding: 24px; background: rgba(220, 38, 38, 0.1); border: 1px solid #dc2626; border-radius: 8px; }
    .danger-zone .section-label { color: #dc2626; margin-bottom: 12px; }
    .danger-zone p { font-size: 13px; color: #94a3b8; margin-bottom: 16px; line-height: 1.5; }
    .danger-zone input { background: #0f172a; margin-top: 0; margin-bottom: 12px; }
    .icon { position: fixed; top: 24px; right: 24px; width: 20px; height: 20px; cursor: pointer; opacity: 0.4; transition: opacity 0.2s; z-index: 10; }
    .icon:hover { opacity: 1; }
    .menu { display: none; position: fixed; top: 52px; right: 24px; background: #1e293b; border: 1px solid #334155; border-radius: 8px; padding: 8px 0; z-index: 20; min-width: 140px; }
    .menu.show { display: block; }
    .menu-item { display: flex; align-items: center; gap: 10px; padding: 10px 16px; color: #94a3b8; font-size: 14px; cursor: pointer; transition: background 0.15s; }
    .menu-item:hover { background: #334155; color: #f8fafc; }
    .menu-item svg { width: 16px; height: 16px; stroke: currentColor; }
    .stats-summary { display: flex; gap: 24px; margin-bottom: 24px; flex-wrap: wrap; }
    .stats-summary span { font-size: 13px; color: #64748b; }
    .stats-summary strong { color: #f8fafc; }
    .sort-row { display: flex; gap: 12px; align-items: center; margin-bottom: 16px; }
    .sort-row select { padding: 8px 12px; background: #1e293b; color: #f8fafc; border: 1px solid #334155; border-radius: 6px; font-size: 13px; outline: none; }
    .sort-row select:focus { border-color: #60a5fa; }
    .word-list { max-height: 60vh; overflow-y: auto; }
    .word-item { display: flex; justify-content: space-between; align-items: center; padding: 12px 0; border-bottom: 1px solid #334155; }
    .word-item:last-child { border-bottom: none; }
    .word-name { font-size: 14px; color: #f8fafc; }
    .word-meta { font-size: 12px; color: #64748b; text-align: right; }
    .word-state { font-size: 10px; padding: 2px 6px; border-radius: 4px; background: #334155; color: #94a3b8; margin-left: 8px; }
    .goal-btn.active { background: #3b82f6; border-color: #3b82f6; color: #fff; }
    .deck-selector { position: fixed; top: 24px; left: 24px; display: flex; align-items: center; padding: 8px 14px; background: #1e293b; border: 1px solid #334155; border-radius: 8px; cursor: pointer; font-size: 14px; color: #94a3b8; transition: all 0.2s; z-index: 10; }
    .deck-selector:hover { border-color: #60a5fa; color: #f8fafc; }
    .deck-menu { display: none; position: fixed; top: 56px; left: 24px; background: #1e293b; border: 1px solid #334155; border-radius: 8px; padding: 8px 0; z-index: 20; min-width: 160px; }
    .deck-menu.show { display: block; }
    .deck-menu-item { display: flex; align-items: center; gap: 10px; padding: 10px 16px; color: #94a3b8; font-size: 14px; cursor: pointer; transition: background 0.15s; }
    .deck-menu-item:hover { background: #334155; color: #f8fafc; }
    .deck-menu-item.active { color: #60a5fa; }
    .deck-menu-item svg { width: 16px; height: 16px; stroke: currentColor; }
    .deck-menu-divider { height: 1px; background: #334155; margin: 8px 0; }
  </style>
</head>
<body>
  <div class="deck-selector" id="deckSelector">
    <span id="currentDeckName">Default</span>
    <svg style="width:12px;height:12px;margin-left:6px;stroke:currentColor" viewBox="0 0 24 24" fill="none" stroke-width="2"><path d="M6 9l6 6 6-6"/></svg>
  </div>
  <div class="deck-menu" id="deckMenu"></div>
  <svg class="icon" id="icon" viewBox="0 0 24 24" fill="none" stroke="#64748b" stroke-width="2" role="button" aria-label="Settings"><circle cx="12" cy="12" r="3"/><path d="M12 1v4M12 19v4M4.2 4.2l2.8 2.8M17 17l2.8 2.8M1 12h4M19 12h4M4.2 19.8l2.8-2.8M17 7l2.8-2.8"/></svg>
  <div class="menu" id="menu">
    <div class="menu-item" id="menuAdd"><svg viewBox="0 0 24 24" fill="none" stroke-width="2"><path d="M12 5v14M5 12h14"/></svg>Add</div>
    <div class="menu-item" id="menuEdit"><svg viewBox="0 0 24 24" fill="none" stroke-width="2"><path d="M11 4H4a2 2 0 00-2 2v14a2 2 0 002 2h14a2 2 0 002-2v-7"/><path d="M18.5 2.5a2.121 2.121 0 013 3L12 15l-4 1 1-4 9.5-9.5z"/></svg>Edit</div>

    <div class="menu-item" id="menuStats"><svg viewBox="0 0 24 24" fill="none" stroke-width="2"><path d="M18 20V10M12 20V4M6 20v-6"/></svg>Stats</div>
    <div class="menu-item" id="menuSettings"><svg viewBox="0 0 24 24" fill="none" stroke-width="2"><circle cx="12" cy="12" r="3"/><path d="M12 1v4M12 19v4M4.2 4.2l2.8 2.8M17 17l2.8 2.8M1 12h4M19 12h4M4.2 19.8l2.8-2.8M17 7l2.8-2.8"/></svg>Settings</div>
  </div>
  <div class="card" id="card">
    <div class="stats"><span id="counter">-</span><span id="stability" title="Memory stability in days"></span><span id="freeze" title="Streak freezes available"><svg style="width:14px;height:14px;vertical-align:middle;margin-right:4px;stroke:#38bdf8;fill:none" viewBox="0 0 24 24" stroke-width="2"><path d="M12 2v20M8 6l4-4 4 4M8 18l4 4 4-4M2 12h4M18 12h4M6 6l2 2M16 16l2 2M6 18l2-2M16 8l2-2"/></svg><span id="freezeNum">0</span></span><span id="streak"><svg style="width:14px;height:14px;vertical-align:middle;margin-right:4px;stroke:#f97316;fill:none" viewBox="0 0 24 24" stroke-width="2"><path d="M12 2c.4 2.3.6 4.5 0 6.5C10.5 5 8 4 6 5c1 2.5 1.5 5 1 7.5C5 11 3 9.5 2 11c1 3 2 6 5 8 1.5 1 3 2 5 2s3.5-1 5-2c3-2 4-5 5-8-1-1.5-3 0-5 1.5.5-2.5 0-5-1-7.5-2-1-4.5 0-6 3.5.6-2 .4-4.2 0-6.5z"/></svg><span id="streakNum">0</span></span></div>
    <div class="progress"><div class="progress-bar" id="progressBar"></div></div>
    <div class="ex" id="ex"></div>
    <div class="def" id="def">Loading...</div>
    <input type="text" id="ans" autofocus>
  </div>

  <!-- Image Display Area -->
  <div id="imageArea" style="display: none; position: relative; left: 50%; right: 50%; margin-left: -50vw; margin-right: -50vw; margin-top: 20px; width: 100vw;">
    <div style="max-width: 1400px; margin: 0 auto; background: #1e293b; border: 1px solid #334155; border-radius: 12px; padding: 16px; box-shadow: 0 4px 24px rgba(0,0,0,0.3);">
      <div style="font-size: 14px; color: #94a3b8; margin-bottom: 12px;">Images for: <strong id="imageWord" style="color: #f8fafc;"></strong></div>
      <div style="width: 100%; height: 500px; border: 1px solid #334155; border-radius: 8px; overflow: hidden;">
        <iframe id="cardImagesFrame" src="" style="width: 100%; height: 100%; border: none;" title="Word Images"></iframe>
      </div>
    </div>
  </div>

  <!-- Edit Modal -->
  <div class="modal" id="editModal">
    <div class="modal-inner">
      <div class="modal-header">
        <span class="modal-title" id="editModalTitle">Edit Card</span>
        <svg class="modal-close" id="closeEdit" viewBox="0 0 24 24" fill="none" stroke="#64748b" stroke-width="2" role="button" aria-label="Close"><path d="M18 6L6 18M6 6l12 12"/></svg>
      </div>
      <div class="section">
        <div class="section-label">Word</div>
        <input type="text" id="word" placeholder="Enter word">
      </div>
      <div class="section">
        <div class="section-label">Definition</div>
        <input type="text" id="defIn" placeholder="Enter definition">
      </div>
      <div class="section">
        <div class="section-label">Example (optional)</div>
        <input type="text" id="exIn" placeholder="Sentence using the word">
      </div>
      <div class="btns">
        <div class="btn btn-primary" id="btnSave"><svg viewBox="0 0 24 24" fill="none" stroke-width="2"><path d="M19 21H5a2 2 0 01-2-2V5a2 2 0 012-2h11l5 5v11a2 2 0 01-2 2zM17 21v-8H7v8M7 3v5h8"/></svg><span id="btnSaveText">Save</span></div>
        <div class="btn btn-danger" id="btnDel" style="display:none"><svg viewBox="0 0 24 24" fill="none" stroke-width="2"><path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6M8 6V4a2 2 0 012-2h4a2 2 0 012 2v2"/></svg>Delete</div>
      </div>
    </div>
  </div>

  <!-- Stats Modal -->
  <div class="modal" id="statsModal">
    <div class="modal-inner">
      <div class="modal-header">
        <span class="modal-title">Stats</span>
        <svg class="modal-close" id="closeStats" viewBox="0 0 24 24" fill="none" stroke="#64748b" stroke-width="2" role="button" aria-label="Close"><path d="M18 6L6 18M6 6l12 12"/></svg>
      </div>
      <div class="stats-summary" id="statsSummary"></div>
      <div class="sort-row">
        <select id="sortBy">
          <option value="due">Due date</option>
          <option value="difficulty">Difficulty</option>
          <option value="stability">Stability</option>
          <option value="lapses">Lapses</option>
          <option value="reps">Reviews</option>
          <option value="last_review">Last reviewed</option>
          <option value="state">State</option>
          <option value="alpha">Alphabetical</option>
        </select>
        <select id="sortDir">
          <option value="asc">Ascending</option>
          <option value="desc">Descending</option>
        </select>
      </div>
      <p id="sortHint" style="font-size:12px;color:#64748b;margin-bottom:16px;font-style:italic;"></p>
      <div class="word-list" id="wordList"></div>
    </div>
  </div>

  <!-- Image Search Modal -->
  <div class="modal" id="imageSearchModal">
    <div class="modal-inner" style="max-width: 95vw; max-height: 90vh;">
      <div class="modal-header">
        <span class="modal-title">Image Search: <span id="searchWord"></span></span>
        <svg class="modal-close" id="closeImageSearch" viewBox="0 0 24 24" fill="none" stroke="#64748b" stroke-width="2" role="button" aria-label="Close"><path d="M18 6L6 18M6 6l12 12"/></svg>
      </div>
      <div style="width: 100%; height: 80vh; border: 1px solid #334155; border-radius: 8px; overflow: hidden;">
        <iframe id="bingImagesFrame" src="" style="width: 100%; height: 100%; border: none;" title="Bing Image Search"></iframe>
      </div>
    </div>
  </div>

  <!-- Settings Modal -->
  <div class="modal" id="settingsModal">
    <div class="modal-inner">
      <div class="modal-header">
        <span class="modal-title">Settings</span>
        <svg class="modal-close" id="closeSettings" viewBox="0 0 24 24" fill="none" stroke="#64748b" stroke-width="2" role="button" aria-label="Close"><path d="M18 6L6 18M6 6l12 12"/></svg>
      </div>
      <div class="section">
        <div class="section-label">Current Deck</div>
        <p style="font-size: 13px; color: #94a3b8; margin-bottom: 12px;"><strong id="settingsDeckName" style="color:#f8fafc"></strong></p>
        <div class="btns">
          <div class="btn" id="btnRenameDeck"><svg viewBox="0 0 24 24" fill="none" stroke-width="2"><path d="M11 4H4a2 2 0 00-2 2v14a2 2 0 002 2h14a2 2 0 002-2v-7"/><path d="M18.5 2.5a2.121 2.121 0 013 3L12 15l-4 1 1-4 9.5-9.5z"/></svg>Rename</div>
          <div class="btn btn-danger" id="btnDeleteDeck"><svg viewBox="0 0 24 24" fill="none" stroke-width="2"><path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6M8 6V4a2 2 0 012-2h4a2 2 0 012 2v2"/></svg>Delete</div>
        </div>
      </div>
      <div class="section">
        <div class="section-label">Session Goal</div>
        <p style="font-size: 13px; color: #94a3b8; margin-bottom: 12px;">Cards per session (wrong answers add more)</p>
        <div class="btns" id="goalBtns">
          <div class="btn goal-btn" data-goal="10">10</div>
          <div class="btn goal-btn" data-goal="25">25</div>
          <div class="btn goal-btn" data-goal="51">51</div>
          <div class="btn goal-btn" data-goal="100">100</div>
        </div>
      </div>
      <div class="section">
        <div class="section-label">Import Cards</div>
        <textarea id="csv" placeholder='Paste exported JSON or card array:

[{"word":"hello","def":"a greeting","ex":"Hello world","card":{...}}]

Tip: Export from another deck to see the format'></textarea>
        <div class="btns">
          <div class="btn" id="btnImport"><svg viewBox="0 0 24 24" fill="none" stroke-width="2"><path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4M17 8l-5-5-5 5M12 3v12"/></svg>Import</div>
        </div>
      </div>
      <div class="section">
        <div class="section-label">Export Cards</div>
        <p style="font-size: 13px; color: #94a3b8; margin-bottom: 12px;">Download all cards as a JSON file.</p>
        <div class="btns">
          <div class="btn" id="btnExport"><svg viewBox="0 0 24 24" fill="none" stroke-width="2"><path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4M7 10l5 5 5-5M12 15V3"/></svg>Export</div>
        </div>
      </div>
      <div class="danger-zone">
        <div class="section-label">Danger Zone</div>
        <p>This will permanently delete all your flashcards. Type <strong style="color:#f8fafc">DELETE</strong> to confirm.</p>
        <input type="text" id="confirmDelete" placeholder="Type DELETE to confirm">
        <div class="btns">
          <div class="btn btn-danger" id="btnClear" disabled><svg viewBox="0 0 24 24" fill="none" stroke-width="2"><path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6"/></svg>Clear All Cards</div>
        </div>
      </div>
    </div>
  </div>
  <script>
    // CDN error handling - show message if module fails to load
    window.addEventListener('error', function(e) {
      if (e.message && e.message.includes('Failed to fetch')) {
        document.getElementById('def').textContent = 'Failed to load. Check your internet connection and refresh.';
      }
    });
    setTimeout(function() {
      if (!window.fsrsLoaded && document.getElementById('def').textContent === 'Loading...') {
        document.getElementById('def').textContent = 'Loading taking too long. Check your connection and refresh.';
      }
    }, 10000);
  </script>
  <script type="module">
    import { FSRS, Rating, createEmptyCard } from 'https://unpkg.com/ts-fsrs/dist/index.mjs';
    window.fsrsLoaded = true;
    const f = new FSRS();

    // Deck management
    let decks = JSON.parse(localStorage.getItem('decks') || '["Default"]');
    let currentDeck = localStorage.getItem('currentDeck') || 'Default';
    if (!decks.includes(currentDeck)) { currentDeck = decks[0] || 'Default'; localStorage.setItem('currentDeck', currentDeck); }
    if (!decks.length) { decks = ['Default']; localStorage.setItem('decks', JSON.stringify(decks)); }

    const getDeckKey = (base) => `${base}_${currentDeck}`;
    let cards = JSON.parse(localStorage.getItem(getDeckKey('fc')) || '[]');
    let cur = null, answered = false, editMode = false;
    let streakData = JSON.parse(localStorage.getItem(getDeckKey('streak')) || '{"count":0,"date":"","freezes":1}');
    if (!streakData.freezes) streakData.freezes = 1;
    let sessionData = JSON.parse(localStorage.getItem(getDeckKey('session')) || '{"count":0,"wrong":0,"words":[],"date":""}');
    const isToday = sessionData.date === new Date().toDateString();
    let sessionCount = isToday ? sessionData.count : 0;
    let wrongCount = isToday ? (sessionData.wrong || 0) : 0;
    let wrongWords = isToday ? (sessionData.words || []) : [];

    const save = () => localStorage.setItem(getDeckKey('fc'), JSON.stringify(cards));
    const due = () => cards.filter(c => new Date(c.card.due) <= new Date());
    const today = () => new Date().toDateString();
    const esc = s => s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;');
    const formatDateDDMMYYYY = d => {
      if (!d) return '';
      const dt = new Date(d);
      return ('0' + dt.getDate()).slice(-2) + '/' + ('0' + (dt.getMonth() + 1)).slice(-2) + '/' + dt.getFullYear();
    };
    let pool = [], poolSize = 0;

    // Deck functions
    const renderDeckMenu = () => {
      currentDeckName.textContent = currentDeck;
      deckMenu.innerHTML = decks.map(d => `<div class="deck-menu-item${d === currentDeck ? ' active' : ''}" data-deck="${esc(d)}">${esc(d)}</div>`).join('') +
        '<div class="deck-menu-divider"></div>' +
        '<div class="deck-menu-item" id="newDeckBtn"><svg viewBox="0 0 24 24" fill="none" stroke-width="2"><path d="M12 5v14M5 12h14"/></svg>New Deck</div>';
      document.querySelectorAll('.deck-menu-item[data-deck]').forEach(item => {
        item.onclick = () => { switchDeck(item.dataset.deck); deckMenu.classList.remove('show'); };
      });
      const newBtn = document.getElementById('newDeckBtn');
      if (newBtn) newBtn.onclick = () => { createNewDeck(); deckMenu.classList.remove('show'); };
    };

    const switchDeck = (deckName) => {
      if (deckName === currentDeck) return;
      currentDeck = deckName;
      localStorage.setItem('currentDeck', currentDeck);
      cards.length = 0;
      JSON.parse(localStorage.getItem(getDeckKey('fc')) || '[]').forEach(c => cards.push(c));
      streakData = JSON.parse(localStorage.getItem(getDeckKey('streak')) || '{"count":0,"date":"","freezes":1}');
      if (!streakData.freezes) streakData.freezes = 1;
      sessionData = JSON.parse(localStorage.getItem(getDeckKey('session')) || '{"count":0,"wrong":0,"words":[],"date":""}');
      const isToday = sessionData.date === new Date().toDateString();
      sessionCount = isToday ? sessionData.count : 0;
      wrongCount = isToday ? (sessionData.wrong || 0) : 0;
      wrongWords = isToday ? (sessionData.words || []) : [];
      pool = []; poolSize = 0;
      cur = null;
      renderDeckMenu();
      next();
    };

    const createNewDeck = () => {
      const name = prompt('Enter deck name:');
      if (!name || !name.trim()) return;
      const deckName = name.trim();
      if (decks.includes(deckName)) { alert('Deck already exists'); return; }
      decks.push(deckName);
      localStorage.setItem('decks', JSON.stringify(decks));
      switchDeck(deckName);
    };

    const deleteDeck = (deckName) => {
      if (decks.length <= 1) { alert('Cannot delete the only deck'); return; }
      if (!confirm(`Delete deck "${deckName}" and all its cards?`)) return;
      decks = decks.filter(d => d !== deckName);
      localStorage.setItem('decks', JSON.stringify(decks));
      localStorage.removeItem(`fc_${deckName}`);
      localStorage.removeItem(`streak_${deckName}`);
      localStorage.removeItem(`session_${deckName}`);
      if (currentDeck === deckName) switchDeck(decks[0]);
      else renderDeckMenu();
    };

    const renameDeck = (oldName) => {
      const newName = prompt('Enter new name:', oldName);
      if (!newName || !newName.trim() || newName.trim() === oldName) return;
      const deckName = newName.trim();
      if (decks.includes(deckName)) { alert('Deck already exists'); return; }
      const idx = decks.indexOf(oldName);
      decks[idx] = deckName;
      localStorage.setItem('decks', JSON.stringify(decks));
      localStorage.setItem(`fc_${deckName}`, localStorage.getItem(`fc_${oldName}`) || '[]');
      localStorage.setItem(`streak_${deckName}`, localStorage.getItem(`streak_${oldName}`) || '{}');
      localStorage.setItem(`session_${deckName}`, localStorage.getItem(`session_${oldName}`) || '{}');
      localStorage.removeItem(`fc_${oldName}`);
      localStorage.removeItem(`streak_${oldName}`);
      localStorage.removeItem(`session_${oldName}`);
      if (currentDeck === oldName) { currentDeck = deckName; localStorage.setItem('currentDeck', currentDeck); }
      renderDeckMenu();
    };
    const updateStreak = () => {
      if (streakData.date === today()) return;
      const yesterday = new Date(Date.now() - 86400000).toDateString();
      const twoDaysAgo = new Date(Date.now() - 172800000).toDateString();
      const oldCount = streakData.count;

      if (streakData.date === yesterday) {
        streakData.count++;
      } else if (streakData.date === twoDaysAgo && (streakData.freezes || 0) > 0) {
        streakData.freezes--;
        streakData.count++;
      } else {
        streakData.count = 1;
      }

      if (streakData.count > 0 && streakData.count % 7 === 0 && streakData.count !== oldCount) {
        streakData.freezes = Math.min((streakData.freezes || 0) + 1, 3);
      }
      streakData.date = today();
      localStorage.setItem(getDeckKey('streak'), JSON.stringify(streakData));
    };

    const saveSession = () => localStorage.setItem(getDeckKey('session'), JSON.stringify({ count: sessionCount, wrong: wrongCount, words: wrongWords, date: new Date().toDateString() }));
    let sessionGoal = parseInt(localStorage.getItem('sessionGoal') || '51');
    const sessionLimit = () => sessionGoal + wrongCount;

    function initPool() {
      sessionCount = 0; wrongCount = 0; wrongWords = [];
      let d = due();
      // If we don't have enough due cards, fill remaining slots with new cards (state 0)
      if (d.length < sessionLimit()) {
        const remainingSlots = sessionLimit() - d.length;
        const newCards = cards.filter(c => c.card.state === 0 && !d.includes(c))
          .sort(() => Math.random() - 0.5)
          .slice(0, remainingSlots);
        d = d.concat(newCards);
      }
      // Sort to prioritize due cards first (cards with passed due dates), then new cards
      pool = d.sort((a, b) => {
        const aDue = new Date(a.card.due) <= new Date();
        const bDue = new Date(b.card.due) <= new Date();
        if (aDue && !bDue) return -1; // a is due, b is not -> a comes first
        if (!aDue && bDue) return 1;  // b is due, a is not -> b comes first
        return Math.random() - 0.5;   // both same type -> random order
      }).slice(0, sessionLimit());
      poolSize = pool.length;
      saveSession();
    }

    function next(pickNew = true) {
      streakNum.textContent = streakData.count;
      freezeNum.textContent = streakData.freezes || 0;
      if (!cards.length) { def.textContent = 'No cards yet'; ex.textContent = ''; ans.style.display = 'none'; counter.textContent = ''; stability.textContent = ''; cur = null; return; }
      if (pickNew && !pool.length && !poolSize) initPool();
      // Handle case where pool is empty after init (no due or new cards)
      if (!pool.length && !poolSize) {
        def.textContent = 'No cards due. Come back later!'; ex.textContent = ''; ans.style.display = 'none'; counter.textContent = '0 / 0'; stability.textContent = ''; cur = null; return;
      }
      if (!pool.length && poolSize) {
        counter.textContent = poolSize + ' / ' + poolSize;
        progressBar.style.width = '100%';
        ex.textContent = ''; ans.style.display = 'none'; stability.textContent = '';
        def.innerHTML = 'Session complete!<div class="btns" style="justify-content:center;margin-top:24px"><div class="btn btn-primary" id="btnNewSession">New Session</div><div class="btn" id="btnDone">Done</div></div>';
        document.getElementById('btnNewSession').onclick = () => { sessionCount = 0; wrongCount = 0; wrongWords = []; pool = []; poolSize = 0; saveSession(); next(); };
        document.getElementById('btnDone').onclick = () => { def.innerHTML = 'See you tomorrow!'; };
        return;
      }
      if (pickNew) {
        sessionCount++;
        saveSession();
        const idx = Math.floor(Math.random() * pool.length);
        cur = pool[idx];
      }
      const done = poolSize - pool.length;
      counter.textContent = done + ' / ' + poolSize;
      progressBar.style.width = (done / poolSize * 100) + '%';
      const stab = cur.card.stability || 0;
      stability.innerHTML = '<svg style="width:14px;height:14px;vertical-align:middle;margin-right:4px;stroke:#60a5fa;fill:none" viewBox="0 0 24 24" stroke-width="2"><path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5"/></svg>' + (stab < 1 ? stab.toFixed(1) : Math.round(stab)) + 'd';
      def.textContent = cur.def + (cur.word ? ' (' + cur.word[0].toLowerCase() + ')' : '');
      const wordText = (cur.word || '').trim();
      const wordPattern = wordText.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      ex.textContent = wordPattern ? (cur.ex || '').replace(new RegExp(wordPattern, 'gi'), '___') : (cur.ex || '');
      ans.value = ''; ans.style.display = ''; ans.classList.remove('correct', 'wrong'); answered = false; ans.focus();
    }

    // TTS function using ElevenLabs API with Web Speech API fallback
    async function speakText(text) {
      if (!text.trim()) return;

      try {
        // Try ElevenLabs first - direct API call
        const response = await fetch('https://api.elevenlabs.io/v1/text-to-speech/JBFqnCBsd6RMkjVDRZzb', {
          method: 'POST',
          headers: {
            'Accept': 'audio/mpeg',
            'Content-Type': 'application/json',
            'xi-api-key': 'sk_816c509f9835260d6a17803159d38e5ccc339c546104f489'
          },
          body: JSON.stringify({
            text: text.trim(),
            model_id: 'eleven_multilingual_v2',
            voice_settings: {
              stability: 0.5,
              similarity_boost: 0.5
            }
          })
        });

        if (!response.ok) {
          throw new Error(`ElevenLabs API error: ${response.status}`);
        }

        const audioBlob = await response.blob();
        const audioUrl = URL.createObjectURL(audioBlob);
        const audio = new Audio(audioUrl);
        await audio.play();

        // Clean up the object URL after playing
        audio.onended = () => URL.revokeObjectURL(audioUrl);

      } catch (error) {
        console.warn('ElevenLabs TTS failed, falling back to Web Speech API:', error);
        // Fallback to Web Speech API
        if ('speechSynthesis' in window) {
          // Cancel any ongoing speech
          speechSynthesis.cancel();
          const utterance = new SpeechSynthesisUtterance(text.trim());
          speechSynthesis.speak(utterance);
        }
      }
    }

    ans.onkeydown = e => {
      if (e.key !== 'Enter' || !cur) return;
      if (answered) {
        // Hide image area when moving to next card
        imageArea.style.display = 'none';
        cardImagesFrame.src = '';
        card.classList.add('fade');
        setTimeout(() => { next(); card.classList.remove('fade'); }, 150);
        return;
      }
      const correct = ans.value.trim().toLowerCase() === (cur.word || '').toLowerCase();
      cur.card = f.repeat(cur.card, new Date())[correct ? Rating.Good : Rating.Again].card;
      if (correct) {
        wrongWords = wrongWords.filter(w => w !== cur.word);
        pool = pool.filter(c => c.word !== cur.word);
      } else {
        wrongCount++;
        if (!wrongWords.includes(cur.word)) wrongWords.push(cur.word);
        card.classList.add('shake'); setTimeout(() => card.classList.remove('shake'), 400);
      }
      saveSession();
      ans.classList.remove('correct', 'wrong');
      ans.classList.add(correct ? 'correct' : 'wrong');
      const wordText = (cur.word || '').trim();
      const wordPattern = wordText.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      ex.style.opacity = '0';
      setTimeout(() => {
        const safeEx = esc(cur.ex || '');
        ex.innerHTML = wordPattern ? safeEx.replace(new RegExp(`(${esc(wordText)})`, 'gi'), `<span style="color:${correct ? '#22c55e' : '#ef4444'};font-weight:600">$1</span>`) : safeEx;
        ex.style.opacity = '1';
        // Speak the complete example sentence after it's revealed
        speakText(ex.textContent || ex.innerText);
        // Show images for the current word
        imageWord.textContent = cur.word;
        const searchQuery = encodeURIComponent(cur.word);
        cardImagesFrame.src = `https://www.bing.com/images/search?q=${searchQuery}`;
        imageArea.style.display = 'block';
      }, 150);
      answered = true; updateStreak(); save(); ans.focus();
    };

    const openEditModal = (edit = false) => {
      editMode = edit;
      editModal.style.display = 'block';
      editModalTitle.textContent = edit ? 'Edit Card' : 'Add New Card';
      btnSaveText.textContent = edit ? 'Save' : 'Add';
      btnDel.style.display = edit && cur ? 'flex' : 'none';
      if (edit && cur) {
        word.value = cur.word;
        defIn.value = cur.def;
        exIn.value = cur.ex || '';
      } else {
        word.value = defIn.value = exIn.value = '';
      }
      word.focus();
    };

    const closeEditModal = () => {
      editModal.style.display = 'none';
      ans.focus();
    };

    const openSettingsModal = () => {
      settingsModal.style.display = 'block';
      confirmDelete.value = '';
      btnClear.disabled = true;
      csv.value = '';
      settingsDeckName.textContent = currentDeck;
      document.querySelectorAll('.goal-btn').forEach(b => b.classList.toggle('active', parseInt(b.dataset.goal) === sessionGoal));
    };

    btnRenameDeck.onclick = () => { renameDeck(currentDeck); settingsDeckName.textContent = currentDeck; };
    btnDeleteDeck.onclick = () => { deleteDeck(currentDeck); closeSettingsModal(); };

    document.querySelectorAll('.goal-btn').forEach(btn => {
      btn.onclick = () => {
        sessionGoal = parseInt(btn.dataset.goal);
        localStorage.setItem('sessionGoal', sessionGoal);
        document.querySelectorAll('.goal-btn').forEach(b => b.classList.toggle('active', b === btn));
      };
    });

    const closeSettingsModal = () => {
      settingsModal.style.display = 'none';
      ans.focus();
    };

    const stateNames = ['New', 'Learning', 'Review', 'Relearning'];
    const openStatsModal = () => {
      statsModal.style.display = 'block';
      const dueNow = cards.filter(c => new Date(c.card.due) <= new Date()).length;
      const byState = [0, 0, 0, 0]; cards.forEach(c => byState[c.card.state]++);
      statsSummary.innerHTML = `<span>Total: <strong>${cards.length}</strong></span><span>Due: <strong>${dueNow}</strong></span><span>New: <strong>${byState[0]}</strong></span><span>Learning: <strong>${byState[1]}</strong></span><span>Review: <strong>${byState[2]}</strong></span>`;
      renderWordList();
    };
    const closeStatsModal = () => { statsModal.style.display = 'none'; ans.focus(); };

    const openImageSearchModal = () => {
      if (!cur || !cur.word) { alert('No word to search for'); return; }
      imageSearchModal.style.display = 'block';
      searchWord.textContent = cur.word;
      const searchQuery = encodeURIComponent(cur.word);
      bingImagesFrame.src = `https://www.bing.com/images/search?q=${searchQuery}`;
    };

    const closeImageSearchModal = () => {
      imageSearchModal.style.display = 'none';
      bingImagesFrame.src = ''; // Clear the iframe src to stop loading
      ans.focus();
    };

    const sortHints = {
      due: "Next scheduled review date for each word.",
      difficulty: "How hard the algorithm thinks this word is (0-10).",
      stability: "Days until you'd forget this word without review.",
      lapses: "Times you got this word wrong after learning it.",
      reps: "Total number of times you've reviewed this word.",
      last_review: "When you last practiced this word.",
      state: "Learning stage: New → Learning → Review → Relearning.",
      alpha: "Simple A-Z sorting by word."
    };

    const renderWordList = () => {
      const sortKey = sortBy.value, dir = sortDir.value === 'asc' ? 1 : -1;
      sortHint.textContent = sortHints[sortKey] || '';
      const sorted = [...cards].sort((a, b) => {
        let av, bv;
        if (sortKey === 'alpha') { av = a.word.toLowerCase(); bv = b.word.toLowerCase(); return av < bv ? -dir : av > bv ? dir : 0; }
        if (sortKey === 'due') { av = new Date(a.card.due); bv = new Date(b.card.due); }
        else if (sortKey === 'last_review') { av = a.card.last_review ? new Date(a.card.last_review) : new Date(0); bv = b.card.last_review ? new Date(b.card.last_review) : new Date(0); }
        else { av = a.card[sortKey] || 0; bv = b.card[sortKey] || 0; }
        return (av - bv) * dir;
      });
      const fmtDate = d => { if (!d) return '-'; const dt = new Date(d); return ('0' + dt.getDate()).slice(-2) + '/' + ('0' + (dt.getMonth() + 1)).slice(-2) + '/' + dt.getFullYear(); };
      const fmtMeta = c => {
        if (sortKey === 'due') return 'Due: ' + fmtDate(c.card.due);
        if (sortKey === 'difficulty') return 'Diff: ' + (c.card.difficulty || 0).toFixed(2);
        if (sortKey === 'stability') return 'Stab: ' + (c.card.stability || 0).toFixed(1) + 'd';
        if (sortKey === 'lapses') return 'Lapses: ' + (c.card.lapses || 0);
        if (sortKey === 'reps') return 'Reviews: ' + (c.card.reps || 0);
        if (sortKey === 'last_review') return 'Last: ' + fmtDate(c.card.last_review);
        if (sortKey === 'state') return stateNames[c.card.state] || 'New';
        return '';
      };
      wordList.innerHTML = sorted.map(c => `<div class="word-item"><span class="word-name">${esc(c.word)}<span class="word-state">${stateNames[c.card.state]}</span></span><span class="word-meta">${fmtMeta(c)}</span></div>`).join('');
    };
    sortBy.onchange = renderWordList;
    sortDir.onchange = renderWordList;

    // Deck menu toggle
    deckSelector.onclick = () => deckMenu.classList.toggle('show');
    document.addEventListener('click', e => { if (!deckMenu.contains(e.target) && !deckSelector.contains(e.target)) deckMenu.classList.remove('show'); });

    // Menu toggle
    const toggleMenu = () => { menu.classList.toggle('show'); menuEdit.style.display = cur ? 'flex' : 'none'; };
    const closeMenu = () => menu.classList.remove('show');
    document.addEventListener('click', e => { if (!menu.contains(e.target) && e.target !== icon) closeMenu(); });

    // Event listeners
    icon.onclick = toggleMenu;
    menuAdd.onclick = () => { closeMenu(); openEditModal(false); };
    menuEdit.onclick = () => { closeMenu(); openEditModal(true); };
    menuStats.onclick = () => { closeMenu(); openStatsModal(); };
    menuSettings.onclick = () => { closeMenu(); openSettingsModal(); };
    closeStats.onclick = closeStatsModal;
    closeSettings.onclick = closeSettingsModal;
    closeEdit.onclick = closeEditModal;
    closeImageSearch.onclick = closeImageSearchModal;

    // Escape key closes modals and menus
    document.addEventListener('keydown', e => {
      if (e.key === 'Escape') {
        if (editModal.style.display === 'block') closeEditModal();
        else if (statsModal.style.display === 'block') closeStatsModal();
        else if (settingsModal.style.display === 'block') closeSettingsModal();
        else if (imageSearchModal.style.display === 'block') closeImageSearchModal();
        closeMenu();
        deckMenu.classList.remove('show');
      }
    });

    confirmDelete.oninput = () => btnClear.disabled = confirmDelete.value !== 'DELETE';

    btnSave.onclick = () => {
      if (!word.value.trim() || !defIn.value.trim()) { alert('Word and definition are required'); return; }
      if (editMode && cur) { cur.word = word.value.trim(); cur.def = defIn.value.trim(); cur.ex = exIn.value.trim(); }
      else cards.push({ word: word.value.trim(), def: defIn.value.trim(), ex: exIn.value.trim(), card: createEmptyCard() });
      save(); closeEditModal(); next();
    };

    btnDel.onclick = () => {
      const i = cards.indexOf(cur);
      if (cur && i >= 0 && confirm('Delete "' + cur.word + '"?')) { cards.splice(i, 1); save(); closeEditModal(); next(); }
    };

    const parseDateDDMMYYYY = d => {
      if (!d || typeof d !== 'string') return d;
      const parts = d.split('/');
      if (parts.length === 3) {
        const day = parseInt(parts[0]);
        const month = parseInt(parts[1]) - 1; // months are 0-indexed
        const year = parseInt(parts[2]);
        if (!isNaN(day) && !isNaN(month) && !isNaN(year)) {
          return new Date(year, month, day).toISOString();
        }
      }
      return d; // return original if parsing fails
    };

    btnImport.onclick = () => {
      if (!csv.value.trim()) return;
      try {
        const imported = JSON.parse(csv.value);
        if (imported.fc && Array.isArray(imported.fc)) {
          const valid = imported.fc.filter(c => c && c.word && c.def && c.card);
          if (!valid.length) { alert('No valid cards'); return; }
          if (imported.deck && imported.deck !== currentDeck) {
            const choice = confirm(`Import to new deck "${imported.deck}"?\n\nOK = Create new deck\nCancel = Import to current deck`);
            if (choice && !decks.includes(imported.deck)) {
              decks.push(imported.deck);
              localStorage.setItem('decks', JSON.stringify(decks));
              currentDeck = imported.deck;
              localStorage.setItem('currentDeck', currentDeck);
              cards.length = 0;
              renderDeckMenu();
            }
          }
          cards.length = 0;
          valid.forEach(c => {
            // Convert date strings back to Date objects for internal storage
            if (c.card.due && typeof c.card.due === 'string') {
              c.card.due = parseDateDDMMYYYY(c.card.due);
            }
            if (c.card.last_review && typeof c.card.last_review === 'string') {
              c.card.last_review = parseDateDDMMYYYY(c.card.last_review);
            }
            cards.push(c);
          });
          save();
          if (imported.streak) {
            streakData = { ...imported.streak, date: parseDateDDMMYYYY(imported.streak.date) };
            localStorage.setItem(getDeckKey('streak'), JSON.stringify(streakData));
          }
          if (imported.session) {
            sessionData = { ...imported.session, date: parseDateDDMMYYYY(imported.session.date) };
            sessionCount = sessionData.count || 0;
            wrongCount = sessionData.wrong || 0;
            wrongWords = sessionData.words || [];
            localStorage.setItem(getDeckKey('session'), JSON.stringify(sessionData));
          }
          pool = []; poolSize = 0;
          csv.value = ''; closeSettingsModal(); next();
          alert('Imported ' + valid.length + ' cards to "' + currentDeck + '"');
        } else if (Array.isArray(imported)) {
          const valid = imported.filter(c => c && c.word && c.def && c.card);
          if (!valid.length) { alert('No valid cards'); return; }
          valid.forEach(c => cards.push(c));
          save(); csv.value = ''; closeSettingsModal(); next();
          alert('Imported ' + valid.length + ' cards');
        } else { alert('Invalid format'); }
      } catch { alert('Invalid JSON'); }
    };

    btnExport.onclick = () => {
      const a = document.createElement('a');
      const data = { deck: currentDeck, fc: cards, streak: { count: streakData.count, date: formatDateDDMMYYYY(streakData.date), freezes: streakData.freezes || 0 }, session: { count: sessionCount, wrong: wrongCount, words: wrongWords, date: formatDateDDMMYYYY(sessionData.date || new Date().toDateString()) } };
      a.href = URL.createObjectURL(new Blob([JSON.stringify(data, null, 2)], {type: 'application/json'}));
      a.download = `${currentDeck.toLowerCase().replace(/\s+/g, '-')}.json`; a.click();
    };

    btnClear.onclick = () => {
      if (confirmDelete.value === 'DELETE') {
        cards.length = 0;
        save();
        closeSettingsModal();
        next();
        alert('All cards have been deleted.');
      }
    };

    // Initialize deck menu and start fresh session
    renderDeckMenu();
    next();
  </script>
</body>
</html>
